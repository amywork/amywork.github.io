<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<meta name="layout" content="post"/>
	<title>&quot;Problem Solving&quot;</title>
	<meta name="author" content="&quot;younari&quot;"/>
</head>
<body>

<blockquote>
<p>사수님께 배운 내용, RayWenderlich DevCon에서 배운 내용, 구글링해서 습득한 내용 등 각종 문제 상황을 해결하면서 남은 지식들을 기록하는 포스트 입니다.</p>
</blockquote>

<h1 id="01.memoryleak">01. Memory Leak</h1>

<ul>
<li>눈에 보이지는 않지만 뒤에서 줄줄 새고 있는 메모리를 관리해보자.</li>
<li><strong>→ 요약</strong>: <strong>Heap Allocation</strong>은 <strong>Deallocation</strong>될 때 <strong>Reference Cycle</strong>이 발생되어 <strong>Memory Leak</strong>이 일어나지 않도록 주의해야 한다.</li>
<li>자식 클래스가 부모 클래스를 참조하는 상황에서는 weak을 통해 부모가 해제되면 자식도 해제될 수 있도록 설계한다.</li>
<li>클로저는 일종의 Instant Class이다. 클로저 블럭에서 값을 캡쳐하는 경우에 retain count를 올려서 메모리 손실을 발생시킬 수 있다. 클로저 블럭에서도 필요한 경우 weak으로 retain count를 막거나 self를 guard로 감쌀 필요가 있다.</li>
</ul>

<p><hr></p>

<ul>
<li><strong>흔히 발생하는 문제</strong>: 뷰콘트롤러의 경우 <strong>클로저에서 self를 캡처</strong> 당했거나 <strong>delegate = self</strong>를 통해 누군가의 대행자가 되면서 해당 뷰콘트롤러의 Retain count를 올리게 된다. 이렇게 되면 ViewController가 Pop되더라도 RetainCount가 0이 되지 않는데, 때문에 힙에 할당된 메모리가 영구 해제될 수 없게된다. 이렇게 되면 앱 크래쉬로 이어질 수 있기 때문에, 개발자는 weak 이나 guard <code>self</code>를 통해 메모리 사이클 관리를 챙겨주어야 한다.</li>
<li><strong>→ 요약</strong>: <strong>Delegate, Closure 에서 weak 챙겨주기!</strong></li>
</ul>

<p><hr></p>

<ul>
<li><strong><em>&#8220;Memory is a limited resource on mobile. Use too much and the jetsam system deamon will kill your app.&#8221;</em></strong> @RayWenderlich, 2017 DevCon, Session 8</li>
</ul>

<p><br></p>

<h1 id="02.frame과bounds">02. Frame과 Bounds</h1>

<ul>
<li>&#8220;너가 어디에 있든 관심이 없고, 너의 보여지는 중앙에 위치하고 싶을 때&#8221; -&gt; Bounds! (대상 뷰의 바운드 mid)</li>
<li>&#8220;나는 너의 종속된 좌표로 들어가고 싶어!&#8221; -&gt; 뷰와 뷰의 구성에는 Frame!</li>
<li>콜렉션뷰 인셋을 주었을 때 바운드 값이 변한다 -&gt; 바운드는 카메라의 위치라고 생각해보자.</li>
</ul>

<p><br></p>

<h1 id="03.copy와deepcopy">03. Copy와 DeepCopy</h1>

<ul>
<li>(objc) <code>DeepCopy</code>는 클래스 내부의 프로퍼티까지 메모리 주소를 싹 다 새로 만든다.</li>
</ul>

<p><br></p>

<h1 id="04.스크롤퍼포먼스">04. 스크롤 퍼포먼스</h1>

<ul>
<li><strong>현상</strong>: 핀터레스트 레이아웃으로, CollectionView에서 2단 그리드 형태로 Cell을 그려낼 때 스크롤 하면서 Cell의 움직임이 버벅이는 현상</li>
<li><strong>원인</strong>: 아이폰은 1초에 60프레임을 그린다. 다른 작업 때문에 Main Thread에서 초당 20프레임 이하로 떨어지면 UI가 버벅이는 현상이 발생한다. UI 작업 이외의 dataRequest 하는 부분은 concurrent로 돌리고, attributedString 등 연산이 들어가는 행위는 Cell마다 하지 않고 1번만 할 수 있도록 분리시킨다.</li>
<li><strong>인사이트</strong>: 메인 스레드에서 UI를 그리는 데 시간을 몰아주어야 한다. 연산은 1번만 한다.</li>
</ul>

<p><br></p>

<h1 id="05.autolayout적용시점">05. AutoLayout 적용 시점</h1>

<ul>
<li>setNeedsLayout / layoutIfNeeded / layoutSubviews의 차이점은 뭘까?</li>
<li>setNeedsLayout: asynchronous update (비동기 업데이트)</li>
<li>layoutIfNeeded: synchronous update (동기 업데이트 = 바로 실행)</li>
<li>layoutSubviews: override method</li>
<li>(발췌) So, stated succinctly, layoutIfNeeded says update immediately please, whereas setNeedsLayout says please update but you can wait until the next update cycle.</li>
<li><a href="http://www.iosinsight.com/setneedslayout-vs-layoutifneeded-explained/">참고자료01</a></li>
<li><a href="https://medium.com/@abhimuralidharan/ios-swift-setneedslayout-vs-layoutifneeded-vs-layoutsubviews-5a2b486da31c">참고자료02</a></li>
</ul>

<p><br></p>

<h1 id="06.initrectcoder">06. init rect &amp; coder</h1>

<ul>
<li>init(rect:)는 뷰를 코드로 생성할때 사용하는 방식</li>
<li>init(coder:)는 뷰를 xib로 생성할때 사용하는 방식</li>
<li>예시로 아래에서는 스토리보드를 통해 init 했으므로, init(coder:)가 불림</li>
</ul>

<pre><code>collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: &quot;MyIdentifier&quot;, for: indexPath) 
</code></pre>

<p><br></p>

<h1 id="07.xcodeconfig">07. Xcode config</h1>

<ul>
<li><a href="http://www.jontolof.com/cocoa/using-xcconfig-files-for-you-xcode-project/">Using xcconfig files</a></li>
</ul>

<p><br></p>

<h1 id="08.scrollview">08. ScrollView</h1>

<ul>
<li><code>scrollRectToVisible(_:animated:)</code></li>
<li><a href="https://developer.apple.com/documentation/uikit/uiscrollview/1619439-scrollrecttovisible#declarations">Apple Doc</a></li>
<li><a href="https://stackoverflow.com/questions/1446536/uiscrollview-works-as-expected-but-scrollrecttovisible-does-nothing">stackoverflow</a></li>
</ul>

<p><br></p>

<h1 id="09.uicolorextension">09. UIColor Extension</h1>

<ul>
<li>UIColor RGB로 컬러 만들기</li>
</ul>

<pre><code>extension UIColor {
    
    static func rgb(_ red: CGFloat, green: CGFloat, blue: CGFloat) -&gt; UIColor {
        return UIColor(red: red/255, green: green/255, blue: blue/255, alpha: 1)
    }
    
}
</code></pre>

<p><br></p>

<h1 id="10.오토레이아웃애니메이션">10. 오토레이아웃 애니메이션</h1>

<ul>
<li>새로운 데이터가 Set 되는 순간, 특정 constraint를 deActive 하고, 다음차 우선순위 constraint가 적용되게끔 하는 테크닉</li>
</ul>

<pre><code>func setTextLabel(_ textData: String?, animated: Bool = true) {
  label.text = textData
  labelContainer.layoutIfNeeded()
  labelWidth.isActive = textData != nil
  UIView.animate(withDuration: animated ? 0.25 : 0, animations: layoutIfNeeded)
}
</code></pre>

<p><br></p>

<h1 id="11.data에didset을통해ui를변경하기">11. Data에 didSet을 통해 UI를 변경하기</h1>

<ul>
<li>@RayWenderlich Devcon 2017. Lyft AutoLayout Guide</li>
</ul>

<pre><code>var separatorsVisible: Bool = false {
  didSet {
    horizontalSeparator.isHidden = !separatorsVisible
    verticalSeparator.isHidden = !separatorsVisible
  }
}
</code></pre>

</body>
</html>
